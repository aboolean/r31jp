#! /usr/bin/env python

import os
import sys
import time
import serial
import subprocess

class ProgressBar(object):
    def __init__(self, start=0, end=10, width=12, fill='=', blank='.', format='[%(fill)s>%(blank)s] %(progress)s%%', incremental=True):
        super(ProgressBar, self).__init__()

        self.start = start
        self.end = end
        self.width = width
        self.fill = fill
        self.blank = blank
        self.format = format
        self.incremental = incremental
        self.step = 100 / float(width) #fix
        self.reset()

    def __add__(self, increment):
        increment = self._get_progress(increment)
        if 100 > self.progress + increment:
            self.progress += increment
        else:
            self.progress = 100
        return self

    def __str__(self):
        progressed = int(self.progress / self.step) #fix
        fill = progressed * self.fill
        blank = (self.width - progressed) * self.blank
        return self.format % {'fill': fill, 'blank': blank, 'progress': int(self.progress)}

    __repr__ = __str__

    def _get_progress(self, increment):
        return float(increment * 100) / self.end

    def reset(self):
        self.progress = self._get_progress(self.start)
        return self

class AnimatedProgressBar(ProgressBar):
    """Extends ProgressBar to allow you to use it straighforward on a script.
    Accepts an extra keyword argument named `stdout` (by default use sys.stdout)
    and may be any file-object to which send the progress status.
    """
    def __init__(self, *args, **kwargs):
        super(AnimatedProgressBar, self).__init__(*args, **kwargs)
        self.stdout = kwargs.get('stdout', sys.stdout)

    def show_progress(self):
        if hasattr(self.stdout, 'isatty') and self.stdout.isatty():
            self.stdout.write('\r')
        else:
            self.stdout.write('\n')
        self.stdout.write(str(self))
        self.stdout.flush()


def serial_write(data):
    for char in data:
        port.write(char)
        port.flush()

def serial_read():
    try:
        return port.read()
    except:
        print 'Error connecting to device'
        sys.exit(1)

def wait_for_char(char):
    while True:
        data = serial_read()
        if data == char:
            break

try:
  port = serial.Serial('/dev/tty.usbserial', baudrate=9600)
except serial.SerialException:
  print 'Could not connect to serial port /dev/tty.usbserial'
  print 'Please confirm you device is plugged in and powered on, and the driver is installed'
  sys.exit(1)

if len(sys.argv) < 2:
    print 'Please specify a file to compile and run'
    sys.exit(1)

as31_process = subprocess.Popen(['as31', '-s', sys.argv[1]], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
program, err = as31_process.communicate()

if 'Error' in err:
    print 'Compilation Error'
    print '\n'.join(err.splitlines()[3:])
    sys.exit(1)

num_lines = len(program.splitlines())

program = program.replace('\n', '')
program = program.replace('\r', '')

print 'Hit RESET in MON mode to load code'

wait_for_char('*')
serial_write('DD')
wait_for_char('>')

print 'Downloading Code...'

serial_write(program)

progress = AnimatedProgressBar(end=num_lines, width=50)

while True:
    data = serial_read()
    if data != '.':
        break
    progress + 1
    progress.show_progress()

port.close()

os.system('clear')
os.system('screen /dev/tty.usbserial 9600')
